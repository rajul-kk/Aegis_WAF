# config/main.co
# Aegis WAF - Colang 2.x Tiered Routing Logic
# All paths return a unified AegisResponse (see verification-schema.json)

import core
import actions

# =============================================================================
# Flow: Main Entry Point - Aegis Tiered Routing
# =============================================================================
flow aegis tiered routing
    """
    The 'Security Sandwich' - 6-layer defense-in-depth pipeline.
    Routes requests based on risk score thresholds.
    All paths build and return an AegisResponse following verification-schema.json.
    """
    user said $user_message

    # Initialize unified response
    $response = await InitAegisResponseAction(session_id=$context.session_id)

    # Layer 1: Fast Scanner (deterministic regex, <10ms)
    $scan_result = await FastScanAction(message=$user_message)
    $response = await UpdateScanResultAction(response=$response, scan_result=$scan_result)

    if $scan_result.blocked
        $response = await FinalizeResponseAction(
            response=$response,
            decision="BLOCK",
            route="FAST_TRACK",
            reason_code="PATTERN_MATCH",
            human_summary="Request blocked: {$scan_result.reason}",
            evidence=$scan_result.patterns_matched,
            triggered_layers=[1]
        )
        bot say $response.json()
        log security event $response
        stop

    # Layer 2: Intent Classification (Llama Guard 3 via NIM)
    $risk_result = await ClassifyIntentAction(message=$user_message)
    $risk_score = $risk_result.risk_score
    $response = await UpdateRiskScoreAction(response=$response, risk_score=$risk_score)

    # Layer 6: Update session risk (async, non-blocking)
    send UpdateSessionRiskAsync(
        session_id=$context.session_id,
        risk_delta=$risk_score
    )

    # Route based on risk score thresholds
    if $risk_score < 0.30
        # Fast-track: Skip CAMEL, proceed to output validation
        await fast track allow path response=$response
    elif $risk_score <= 0.70
        # Light CAMEL: 2 agents, 1 round
        await light camel verification path response=$response
    else
        # Full CAMEL: 5 agents, multi-round consensus
        await full camel verification path response=$response


# =============================================================================
# Flow: Fast Track Allow (risk < 0.30)
# =============================================================================
flow fast track allow path response=$response
    """
    Fast-track path for low-risk requests.
    Target latency: <80ms total.
    Returns AegisResponse with route=FAST_TRACK, council fields zeroed.
    """
    $response = await SetRouteAction(response=$response, route="FAST_TRACK")

    # Generate response using main LLM
    $llm_response = await GenerateResponseAction(context=$context)

    # Layer 3.5: Output validation before returning
    await validate and return output response=$response llm_response=$llm_response


# =============================================================================
# Flow: Light CAMEL Verification (0.30 <= risk <= 0.70)
# =============================================================================
flow light camel verification path response=$response
    """
    Light security council: 2 agents, 1 reasoning round.
    Target latency: <500ms.
    Returns AegisResponse with route=LIGHT_CAMEL.
    """
    $response = await SetRouteAction(response=$response, route="LIGHT_CAMEL")

    $camel_result = await CamelVerifyAction(
        message=$user_message,
        mode="light",
        agents=["SecurityAnalyst", "PolicyEnforcer"],
        rounds=1
    )
    $response = await UpdateCouncilResultAction(response=$response, camel_result=$camel_result)

    if $camel_result.decision == "block"
        $response = await FinalizeResponseAction(
            response=$response,
            decision="BLOCK",
            route="LIGHT_CAMEL",
            reason_code="CAMEL_BLOCK",
            human_summary="Request blocked after security review: {$camel_result.reason}",
            evidence=$camel_result.evidence,
            triggered_layers=[1, 2, 3]
        )
        bot say $response.json()
        log security event $response
        stop

    # Passed verification, generate and validate response
    $llm_response = await GenerateResponseAction(context=$context)
    await validate and return output response=$response llm_response=$llm_response


# =============================================================================
# Flow: Full CAMEL Verification (risk > 0.70)
# =============================================================================
flow full camel verification path response=$response
    """
    Full security council: 5 agents, multi-round consensus.
    Target latency: <2000ms.
    Returns AegisResponse with route=FULL_CAMEL.
    """
    $response = await SetRouteAction(response=$response, route="FULL_CAMEL")

    $camel_result = await CamelVerifyAction(
        message=$user_message,
        mode="full",
        agents=[
            "SecurityAnalyst",
            "AdversarialTester",
            "PolicyEnforcer",
            "EthicsReviewer",
            "FinalArbiter"
        ],
        rounds=3,
        consensus_threshold=0.6
    )
    $response = await UpdateCouncilResultAction(response=$response, camel_result=$camel_result)

    if $camel_result.decision == "block"
        $response = await FinalizeResponseAction(
            response=$response,
            decision="BLOCK",
            route="FULL_CAMEL",
            reason_code="CONSENSUS_BLOCK",
            human_summary="Request blocked by security council: {$camel_result.reason}",
            evidence=$camel_result.evidence,
            triggered_layers=[1, 2, 3]
        )
        bot say $response.json()
        log security event $response
        stop

    # Passed full verification
    $llm_response = await GenerateResponseAction(context=$context)
    await validate and return output response=$response llm_response=$llm_response


# =============================================================================
# Flow: Output Validation (Layer 3.5)
# =============================================================================
flow validate and return output response=$response llm_response=$llm_response
    """
    Layer 3.5: Validates AI responses before returning to user.
    - Tool call whitelisting
    - PII scrubbing
    - Secret detection
    Updates AegisResponse with output_validation results.
    """
    $validated = await ValidateOutputAction(
        response=$llm_response,
        check_tools=True,
        scrub_pii=True,
        detect_secrets=True
    )
    $response = await UpdateOutputValidationAction(response=$response, validated=$validated)

    if $validated.blocked
        $response = await FinalizeResponseAction(
            response=$response,
            decision="BLOCK",
            reason_code="OUTPUT_VIOLATION",
            human_summary="Response blocked: contains disallowed content",
            evidence=$validated.issues,
            triggered_layers=$response.explanation.triggered_layers + [3]
        )
        bot say $response.json()
        log security event $response
        stop

    # Determine final decision: SANITIZED if output was modified, ALLOW otherwise
    if $validated.was_modified
        $response = await FinalizeResponseAction(
            response=$response,
            decision="SANITIZED",
            reason_code="CLEAN",
            human_summary="Response allowed after sanitization",
            triggered_layers=$response.explanation.triggered_layers + [3]
        )
    else
        $response = await FinalizeResponseAction(
            response=$response,
            decision="ALLOW",
            reason_code="CLEAN",
            human_summary="Request allowed",
            triggered_layers=$response.explanation.triggered_layers
        )

    # Return the unified AegisResponse as JSON
    bot say $response.json()


# =============================================================================
# Flow: Output Validation Rail
# =============================================================================
flow aegis output validation
    """
    Output rail that intercepts all bot responses for validation.
    """
    bot said $bot_message

    $validated = await ValidateOutputAction(
        response=$bot_message,
        check_tools=True,
        scrub_pii=True,
        detect_secrets=True
    )

    if $validated.blocked
        bot say "I cannot provide that response due to security policies."
        stop

    if $validated.was_modified
        # Response was scrubbed, use cleaned version
        bot say $validated.cleaned_response
        stop

    # Original response is safe
    bot say $bot_message
